<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Tank (PBR & Tangent Space Normal)</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
        outline: none;
      }
    </style>
  </head>
  <body>
    <canvas id="webgpu-canvas" tabindex="1"></canvas>
    <script type="importmap">
      {
        "imports": {
          "three": "https://threejs.org/build/three.module.min.js",
          "three/addons/": "https://threejs.org/examples/jsm/",
          "wgpu-matrix": "https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.min.js"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { OBJLoader } from "three/addons/loaders/OBJLoader.js";
      import { vec2, vec3, vec4, mat4, utils } from "wgpu-matrix";

      const format_depth_texture = "depth24plus";

      class UI {
        static NONE = 0;
        static ROTATING = 1;
        static TRANSLATING = 2;
        static mouseMove = UI.NONE;
        static camera = {
          fovy: 45,
          position: vec3.create(-0.2, -0.5, -4),
          near: 0.1,
          far: 100,
        };
        static matrices = { P: null, R: null, VP: null };

        static onmousedown(ev) {
          if (ev.buttons === 1) {
            if (ev.metaKey || ev.ctrlKey) UI.mouseMove = UI.TRANSLATING;
            else UI.mouseMove = UI.ROTATING;
          }
        }
        static onmouseup(ev) {
          UI.mouseMove = UI.NONE;
        }
        static onmousemove(ev) {
          let offset = [ev.movementX, ev.movementY];
          if (UI.mouseMove == UI.ROTATING) {
            UI.update_VP();
            let axis = unproject_vector(
              [offset[1], offset[0], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.matrices.R = mat4.rotate(
              UI.matrices.R,
              [axis[0], axis[1], axis[2]],
              utils.degToRad(vec2.lenSq(offset) * 0.1)
            );
          } else if (UI.mouseMove == UI.TRANSLATING) {
            UI.update_VP();
            let by = unproject_vector(
              [offset[0], -offset[1], 0],
              UI.matrices.VP,
              [0, 0, UI.canvas.clientWidth, UI.canvas.clientHeight]
            );
            UI.camera.position = vec3.add(
              UI.camera.position,
              vec3.transformMat4(
                vec3.create(by[0], by[1], by[2]),
                UI.matrices.R
              )
            );
          }
        }
        static onwheel(ev) {
          ev.preventDefault();
          UI.camera.position[2] = -Math.max(
            1,
            Math.min(-UI.camera.position[2] + ev.deltaY * 0.01, 50)
          );
          UI.update_VP();
        }
        static update_VP() {
          UI.matrices.P = mat4.perspective(
            utils.degToRad(UI.camera.fovy),
            UI.canvas.width / UI.canvas.height,
            UI.camera.near,
            UI.camera.far
          );
          if (!UI.matrices.R) UI.matrices.R = mat4.identity();
          let T = mat4.translate(UI.matrices.P, UI.camera.position);
          UI.matrices.VP = mat4.multiply(T, UI.matrices.R);
        }
      }

      function project(p_obj, MVP, viewport) {
        let tmp = vec4.transformMat4(p_obj, MVP);
        tmp = tmp.map((x) => x / tmp[3]);
        for (let i = 0; i < 2; i++)
          tmp[i] = (0.5 * tmp[i] + 0.5) * viewport[i + 2] + viewport[i];
        return tmp;
      }

      function unproject(p_win, MVP, viewport) {
        let MVP_inv = mat4.invert(MVP);
        let tmp = mat4.clone(p_win);
        for (let i = 0; i < 2; i++)
          tmp[i] = (2.0 * (tmp[i] - viewport[i])) / viewport[i + 2] - 1.0;
        let p_obj = vec4.transformMat4(tmp, MVP_inv);
        p_obj = p_obj.map((x) => x / p_obj[3]);
        return p_obj;
      }

      function unproject_vector(vec_win, MVP, viewport) {
        let org_win = project([0, 0, 0, 1], MVP, viewport);
        let vec = unproject(
          [
            org_win[0] + vec_win[0],
            org_win[1] + vec_win[1],
            org_win[2] + vec_win[2],
            1,
          ],
          MVP,
          viewport
        );
        return vec;
      }

      function computeTangents(positions, normals, uvs, indices) {
        const vertexCount = positions.length / 3;
        const tangents = new Float32Array(vertexCount * 3);
        const bitangents = new Float32Array(vertexCount * 3);

        for (let i = 0; i < indices.length; i += 3) {
          const i0 = indices[i],
            i1 = indices[i + 1],
            i2 = indices[i + 2];
          const x0 = positions[i0 * 3],
            y0 = positions[i0 * 3 + 1],
            z0 = positions[i0 * 3 + 2];
          const x1 = positions[i1 * 3],
            y1 = positions[i1 * 3 + 1],
            z1 = positions[i1 * 3 + 2];
          const x2 = positions[i2 * 3],
            y2 = positions[i2 * 3 + 1],
            z2 = positions[i2 * 3 + 2];

          const u0 = uvs[i0 * 2],
            v0 = uvs[i0 * 2 + 1];
          const u1 = uvs[i1 * 2],
            v1 = uvs[i1 * 2 + 1];
          const u2 = uvs[i2 * 2],
            v2 = uvs[i2 * 2 + 1];

          const E1x = x1 - x0,
            E1y = y1 - y0,
            E1z = z1 - z0;
          const E2x = x2 - x0,
            E2y = y2 - y0,
            E2z = z2 - z0;
          const dU1 = u1 - u0,
            dV1 = v1 - v0;
          const dU2 = u2 - u0,
            dV2 = v2 - v0;

          let denom = dU1 * dV2 - dU2 * dV1;
          if (denom === 0.0) continue;
          const r = 1.0 / denom;
          const Tx = (E1x * dV2 - E2x * dV1) * r;
          const Ty = (E1y * dV2 - E2y * dV1) * r;
          const Tz = (E1z * dV2 - E2z * dV1) * r;
          const Bx = (E2x * dU1 - E1x * dU2) * r;
          const By = (E2y * dU1 - E1y * dU2) * r;
          const Bz = (E2z * dU1 - E1z * dU2) * r;

          tangents[i0 * 3] += Tx;
          tangents[i0 * 3 + 1] += Ty;
          tangents[i0 * 3 + 2] += Tz;
          tangents[i1 * 3] += Tx;
          tangents[i1 * 3 + 1] += Ty;
          tangents[i1 * 3 + 2] += Tz;
          tangents[i2 * 3] += Tx;
          tangents[i2 * 3 + 1] += Ty;
          tangents[i2 * 3 + 2] += Tz;

          bitangents[i0 * 3] += Bx;
          bitangents[i0 * 3 + 1] += By;
          bitangents[i0 * 3 + 2] += Bz;
          bitangents[i1 * 3] += Bx;
          bitangents[i1 * 3 + 1] += By;
          bitangents[i1 * 3 + 2] += Bz;
          bitangents[i2 * 3] += Bx;
          bitangents[i2 * 3 + 1] += By;
          bitangents[i2 * 3 + 2] += Bz;
        }

        for (let i = 0; i < vertexCount; i++) {
          const nx = normals[i * 3],
            ny = normals[i * 3 + 1],
            nz = normals[i * 3 + 2];
          let tx = tangents[i * 3],
            ty = tangents[i * 3 + 1],
            tz = tangents[i * 3 + 2];
          const NdotT = nx * tx + ny * ty + nz * tz;
          tx = tx - NdotT * nx;
          ty = ty - NdotT * ny;
          tz = tz - NdotT * nz;
          let tlen = Math.sqrt(tx * tx + ty * ty + tz * tz);
          if (tlen > 0.0) {
            tx /= tlen;
            ty /= tlen;
            tz /= tlen;
          }
          tangents[i * 3] = tx;
          tangents[i * 3 + 1] = ty;
          tangents[i * 3 + 2] = tz;

          let bx = bitangents[i * 3],
            by = bitangents[i * 3 + 1],
            bz = bitangents[i * 3 + 2];
          const NdotB = nx * bx + ny * by + nz * bz;
          bx = bx - NdotB * nx;
          by = by - NdotB * ny;
          bz = bz - NdotB * nz;
          let blen = Math.sqrt(bx * bx + by * by + bz * bz);
          if (blen > 0.0) {
            bx /= blen;
            by /= blen;
            bz /= blen;
          }
          bitangents[i * 3] = bx;
          bitangents[i * 3 + 1] = by;
          bitangents[i * 3 + 2] = bz;
        }

        return { tangents, bitangents };
      }

      async function loadAllMeshesFromGLTF(device, url) {
        const loader = new GLTFLoader();
        const gltf = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (g) => resolve(g),
            undefined,
            (e) => reject(e)
          );
        });

        let meshes = [];
        gltf.scene.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in gltf");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let obj of meshes) {
          const positions = obj.geometry.attributes.position.array;

          const normals = obj.geometry.attributes.normal.array;
          const uvs = obj.geometry.attributes.uv
            ? obj.geometry.attributes.uv.array
            : new Float32Array((positions.length / 3) * 2);
          let indices = obj.geometry.index.array;
          if (!(indices instanceof Uint32Array)) {
            const tmp = new Uint32Array(indices.length);
            for (let i = 0; i < indices.length; i++) tmp[i] = indices[i];
            indices = tmp;
          }

          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      async function loadImageAsTexture(device, url) {
        const img = new Image();
        img.src = url;
        await img.decode();
        const bitmap = await createImageBitmap(img, {
          colorSpaceConversion: "none",
        });
        const texture = device.createTexture({
          label: url,
          format: "rgba8unorm",
          size: [bitmap.width, bitmap.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture(
          { source: bitmap },
          { texture: texture },
          [bitmap.width, bitmap.height]
        );
        return texture;
      }

      function createSampler(device) {
        return device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });
      }

      function createDepthTexture(device, width, height, format) {
        return device.createTexture({
          size: [width, height],
          format: format,
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
      }

      async function loadOBJAsMeshes(device, url) {
        const loader = new OBJLoader();
        const obj = await new Promise((resolve, reject) => {
          loader.load(
            url,
            (obj) => resolve(obj),
            undefined,
            (e) => reject(e)
          );
        });
        // obj.children 중 Mesh 찾아 geometry 읽기
        let meshes = [];
        obj.traverse((c) => {
          if (c.isMesh && c.geometry) meshes.push(c);
        });
        if (meshes.length == 0) throw Error("No meshes found in obj");

        function createBufferFromArray(arr, usage) {
          const buf = device.createBuffer({
            size: arr.byteLength,
            usage: usage | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(buf, 0, arr);
          return buf;
        }

        let meshData = [];
        for (let m of meshes) {
          const geom = m.geometry;
          const positions = geom.attributes.position.array;
          const normals = geom.attributes.normal.array;
          let uvs;
          if (geom.attributes.uv) uvs = geom.attributes.uv.array;
          else uvs = new Float32Array((positions.length / 3) * 2);
          let indices;
          if (geom.index) indices = geom.index.array;
          else {
            let count = positions.length / 3;
            indices = new Uint32Array(count);
            for (let i = 0; i < count; i++) indices[i] = i;
          }

          const { tangents, bitangents } = computeTangents(
            positions,
            normals,
            uvs,
            indices
          );

          const posBuffer = createBufferFromArray(
            positions,
            GPUBufferUsage.VERTEX
          );
          const normalBuffer = createBufferFromArray(
            normals,
            GPUBufferUsage.VERTEX
          );
          const uvBuffer = createBufferFromArray(uvs, GPUBufferUsage.VERTEX);
          const tangentBuffer = createBufferFromArray(
            tangents,
            GPUBufferUsage.VERTEX
          );
          const bitangentBuffer = createBufferFromArray(
            bitangents,
            GPUBufferUsage.VERTEX
          );
          const indexBuffer = createBufferFromArray(
            indices,
            GPUBufferUsage.INDEX
          );
          meshData.push({
            posBuffer,
            normalBuffer,
            uvBuffer,
            tangentBuffer,
            bitangentBuffer,
            indexBuffer,
            indexCount: indices.length,
          });
        }
        return meshData;
      }

      const vertexShaderWGSL = `@group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
      @group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;
      @group(0) @binding(2) var<uniform> normalMatrix: mat4x4<f32>;

      struct VertexInput {
        @location(0) position: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) tangent: vec3<f32>,
        @location(4) bitangent: vec3<f32>,
      };

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) fragPos: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) tangent: vec3<f32>,
        @location(4) bitangent: vec3<f32>,
      };

      @vertex
      fn main(input: VertexInput) -> VertexOutput {
        var output: VertexOutput;
        let worldPos = modelMatrix * vec4<f32>(input.position, 1.0);
        output.position = sceneUniform * worldPos;
        output.fragPos = worldPos.xyz;

        output.normal = normalize((normalMatrix * vec4<f32>(input.normal, 0.0)).xyz);
        output.tangent = normalize((modelMatrix * vec4<f32>(input.tangent, 0.0)).xyz);
        output.bitangent = normalize((modelMatrix * vec4<f32>(input.bitangent, 0.0)).xyz);

        output.uv = input.uv;
        return output;
      }`;

      const fragmentShaderWGSL = `
      @group(0) @binding(3) var<uniform> lightDirection: vec3<f32>;
      @group(0) @binding(4) var colorTex: texture_2d<f32>;
      @group(0) @binding(5) var etcTex: texture_2d<f32>;
      @group(0) @binding(6) var normalTex: texture_2d<f32>;
      @group(0) @binding(7) var mySampler: sampler;
      @group(0) @binding(8) var<uniform> partUniform: u32;

      const PI = 3.14159265359;

      fn fresnelSchlick(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {
        return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
      }

      fn ndfGGX(N: vec3<f32>, H: vec3<f32>, roughness: f32) -> f32 {
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let denom = NdotH2 * (a2 - 1.0) + 1.0;
        return a2 / (PI * denom * denom);
      }

      fn geometrySmith(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, roughness: f32) -> f32 {
        let k = (roughness + 1.0)*(roughness + 1.0)/8.0;
        let NdotV = max(dot(N,V),0.0);
        let NdotL = max(dot(N,L),0.0);
        let G1V = NdotV/(NdotV*(1.0-k)+k);
        let G1L = NdotL/(NdotL*(1.0-k)+k);
        return G1V * G1L;
      }

      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) fragPos: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) uv: vec2<f32>,
        @location(3) tangent: vec3<f32>,
        @location(4) bitangent: vec3<f32>,
      };

      @fragment
      fn main(input: VertexOutput)->@location(0) vec4<f32> {
        let baseColor_srgb = textureSample(colorTex,mySampler,input.uv).rgb;
        var baseColor = pow(baseColor_srgb, vec3<f32>(2.2));

        let etcColor = textureSample(etcTex,mySampler,input.uv);
        let AO = etcColor.r;
        var roughness = etcColor.g;
        var metallic = etcColor.b;

        let normalSample = textureSample(normalTex, mySampler, input.uv).rgb;
        let N_map = normalSample * 2.0 - 1.0;
        let tangentNormal = normalize(-N_map);

        let T = normalize(input.tangent);
        let B = normalize(input.bitangent);
        let N = normalize(input.normal);
        let TBN = mat3x3<f32>(T, B, N);

        let worldNormal = normalize(TBN * tangentNormal);

        if (partUniform == 2u) {
          metallic = 0.1;
          roughness = 0.05;
          baseColor = vec3<f32>(0.38, 0.37, 0.36);


          // rustMask를 g채널에서 추출 (0~1)
          let rustMask = textureSample(etcTex, mySampler, input.uv).g;

          // AO 기반으로 녹 섞기 (AO 낮을수록 녹심)
          let rustFactorAO = smoothstep(0.1, 0.5, AO);

          let noise = 0.5 + 0.5*sin(input.uv.x*50.0 + input.uv.y*50.0);
          let combinedRustFactor = rustMask * rustFactorAO;

          let rustColor = vec3<f32>(0.02, 0.01, 0.005);
          baseColor = mix(baseColor, rustColor, combinedRustFactor);

          // 녹 부분은 금속성 줄이고 더 거칠게
          metallic = mix(metallic, 0.0, combinedRustFactor);
          roughness = mix(roughness, 0.85, combinedRustFactor);
        }

        let L = normalize(-lightDirection);
        let V = normalize(-input.fragPos);
        let H = normalize(L + V);

        let NdotV = max(dot(worldNormal, V),0.0);
        let NdotL = max(dot(worldNormal, L),0.0);

        let NDF = ndfGGX(worldNormal, H, roughness);
        let G = geometrySmith(worldNormal, V, L, roughness);
        let F0 = mix(vec3<f32>(0.04,0.04,0.04), baseColor, metallic);
        let F = fresnelSchlick(max(dot(H, V),0.0), F0);

        let kS = F * (NDF * G) / (4.0 * NdotV * NdotL + 0.001);
        let kD = (vec3<f32>(1.0)-F)*(1.0-metallic);

        let diffuse = NdotL * baseColor;
        let ambientIntensity = 0.0001;
        let ambient = AO * AO * vec3<f32>(ambientIntensity, ambientIntensity, ambientIntensity);

        var finalColor = ambient + kD*diffuse + kS;

        let gamma = 2.2;
        finalColor = pow(finalColor, vec3<f32>(1.0/gamma));
        return vec4<f32>(finalColor, 1.0);
      }
      `;

      function createRenderPipeline(
        device,
        vertexModule,
        fragmentModule,
        depthFormat,
        preferredFormat
      ) {
        return device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: vertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 4 * 3, // position
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // normal
                attributes: [
                  { shaderLocation: 1, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 2, // uv
                attributes: [
                  { shaderLocation: 2, offset: 0, format: "float32x2" },
                ],
              },
              {
                arrayStride: 4 * 3, // tangent
                attributes: [
                  { shaderLocation: 3, offset: 0, format: "float32x3" },
                ],
              },
              {
                arrayStride: 4 * 3, // bitangent
                attributes: [
                  { shaderLocation: 4, offset: 0, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: fragmentModule,
            entryPoint: "main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "triangle-list" },
          depthStencil: {
            format: depthFormat,
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });
      }

      let shellLaunched = false;
      let shellPaused = false;
      let shellPos = [0, 0, 0];
      let shellVel = [0, 0, 0];
      const gravity = 9.8 * 0.3;
      const initialSpeed = 3.0;
      let M_barrel_glob = new Float32Array(16); // 전역 배럴 매트릭스

      function updateShell() {
        if (shellLaunched && !shellPaused) {
          let dt = 1 / 60;
          shellVel[1] -= gravity * dt;
          shellPos[0] += shellVel[0] * dt;
          shellPos[1] += shellVel[1] * dt;
          shellPos[2] += shellVel[2] * dt;
          if (shellPos[1] < 0) {
            shellPos[1] = 0;
            shellVel = [0, 0, 0];
          }
        }
      }

      async function main() {
        const canvas = document.getElementById("webgpu-canvas");
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        const context = canvas.getContext("webgpu");
        const preferredFormat = navigator.gpu.getPreferredCanvasFormat();

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        context.configure({
          device: device,
          format: preferredFormat,
          alphaMode: "opaque",
        });

        canvas.onmousedown = UI.onmousedown;
        canvas.onmouseup = UI.onmouseup;
        canvas.onmousemove = UI.onmousemove;
        window.addEventListener("wheel", UI.onwheel, { passive: false });

        UI.canvas = canvas;
        UI.update_VP();

        // 탱크 로딩
        const meshData = await loadAllMeshesFromGLTF(device, "models/tank.glb");
        // const shellData = await loadAllMeshesFromGLTF(
        //   device,
        //   "models/88mm_shell.glb"
        // );
        const shellData = await loadOBJAsMeshes(device, "models/shell.obj");

        // 텍스처 로딩
        const tankColor = await loadImageAsTexture(
          device,
          "textures/tank-color.jpeg"
        );
        const tankEtc = await loadImageAsTexture(
          device,
          "textures/tank-etc.png"
        );
        const tankNormal = await loadImageAsTexture(
          device,
          "textures/tank-normal.png"
        );

        const shellColor = await loadImageAsTexture(
          device,
          "textures/shell-color.png"
        );
        const shellEtc = await loadImageAsTexture(
          device,
          "textures/shell-etc.png"
        );
        const shellNormal = await loadImageAsTexture(
          device,
          "textures/shell-normal.png"
        );

        const sampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
          mipmapFilter: "linear",
          maxAnisotropy: 16,
        });

        const sceneBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const modelBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const normalMatrixBuffer = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const modelBufferShell = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const normalMatrixBufferShell = device.createBuffer({
          size: 64,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        const lightBuffer = device.createBuffer({
          size: 12,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        function createPartIDBuffer(id) {
          const buf = device.createBuffer({
            size: 4,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true,
          });
          new Uint32Array(buf.getMappedRange())[0] = id;
          buf.unmap();
          return buf;
        }

        function someInvTransposeOf(M) {
          // M을 복사(또는 clone)해서 사용하면 원본 행렬이 바뀌는 것을 방지할 수 있습니다.
          let tmp = mat4.clone(M);

          // 1) invert(M)
          let inv = mat4.invert(tmp);

          // 2) transpose(invert(M))
          let invT = mat4.transpose(inv);

          return invT; // Float32Array(16)
        }

        // partIDs: 0=body,1=turret,2=innerWheel,3=outerWheel,4=barrel,5=shell
        const partIDBuffer_Body = createPartIDBuffer(0);
        const partIDBuffer_Turret = createPartIDBuffer(1);
        const partIDBuffer_InnerWheel = createPartIDBuffer(2);
        const partIDBuffer_OuterWheel = createPartIDBuffer(3);
        const partIDBuffer_Barrel = createPartIDBuffer(4);
        const partIDBuffer_Shell = createPartIDBuffer(5); // 쉘 존재 시

        const vertexModule = device.createShaderModule({
          code: vertexShaderWGSL,
        });
        const fragmentModule = device.createShaderModule({
          code: fragmentShaderWGSL,
        });

        const pipeline = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        const pipelineShell = createRenderPipeline(
          device,
          vertexModule,
          fragmentModule,
          "depth24plus",
          preferredFormat
        );

        function createBindGroup(colorTex, etcTex, normalTex, partIDBuf) {
          return device.createBindGroup({
            layout: pipeline.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: sceneBuffer } },
              { binding: 1, resource: { buffer: modelBuffer } },
              { binding: 2, resource: { buffer: normalMatrixBuffer } },
              { binding: 3, resource: { buffer: lightBuffer } },
              { binding: 4, resource: colorTex.createView() },
              { binding: 5, resource: etcTex.createView() },
              { binding: 6, resource: normalTex.createView() },
              { binding: 7, resource: sampler },
              { binding: 8, resource: { buffer: partIDBuf } },
            ],
          });
        }

        function createShellBindGroup(colorTex, etcTex, normalTex, partIDBuf) {
          return device.createBindGroup({
            layout: pipelineShell.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: sceneBuffer } },
              { binding: 1, resource: { buffer: modelBufferShell } },
              { binding: 2, resource: { buffer: normalMatrixBufferShell } },
              { binding: 3, resource: { buffer: lightBuffer } },
              { binding: 4, resource: colorTex.createView() },
              { binding: 5, resource: etcTex.createView() },
              { binding: 6, resource: normalTex.createView() },
              { binding: 7, resource: sampler },
              { binding: 8, resource: { buffer: partIDBuf } },
            ],
          });
        }

        const bindGroup_Body = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Body
        );
        const bindGroup_Turret = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Turret
        );
        const bindGroup_InnerWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_InnerWheel
        );
        const bindGroup_OuterWheel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_OuterWheel
        );
        const bindGroup_Barrel = createBindGroup(
          tankColor,
          tankEtc,
          tankNormal,
          partIDBuffer_Barrel
        );
        const bindGroup_Shell = createShellBindGroup(
          shellColor,
          shellEtc,
          shellNormal,
          partIDBuffer_Shell
        );

        // 그리드와 로컬 축 파이프라인
        const gridVertexCode = `
      @group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;

      struct VertexInput {
        @location(0) position: vec3<f32>,
        @location(1) color: vec3<f32>,
      };
      struct VertexOutput {
        @builtin(position) position: vec4<f32>,
        @location(0) color: vec3<f32>,
      };

      @vertex
      fn main(input:VertexInput)->VertexOutput{
        var output:VertexOutput;
        output.position=sceneUniform*vec4<f32>(input.position,1.0);
        output.color=input.color;
        return output;
      }

      @fragment
      fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
        return vec4<f32>(input.color,1.0);
      }`;

        const gridModule = device.createShaderModule({ code: gridVertexCode });
        const gridPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: gridModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: gridModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: gridBuffer, vertexCount: gridVertexCount } =
          (function createGridAndAxesBuffers(device) {
            const lines = [];
            lines.push(...[0, 0, 0, 1, 0, 0]);
            lines.push(...[1, 0, 0, 1, 0, 0]);
            lines.push(...[0, 0, 0, 0, 1, 0]);
            lines.push(...[0, 1, 0, 0, 1, 0]);
            lines.push(...[0, 0, 0, 0, 0, 1]);
            lines.push(...[0, 0, 1, 0, 0, 1]);

            for (let i = -5; i <= 5; i++) {
              lines.push(...[-5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[5, 0, i, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, -5, 1.0, 1.0, 1.0]);
              lines.push(...[i, 0, 5, 1.0, 1.0, 1.0]);
            }

            const data = new Float32Array(lines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: data.length / 6 };
          })(device);

        const gridBindGroup = device.createBindGroup({
          layout: gridPipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: sceneBuffer } }],
        });

        const localAxesVertexCode = `
      @group(0) @binding(0) var<uniform> sceneUniform: mat4x4<f32>;
      @group(0) @binding(1) var<uniform> modelMatrix: mat4x4<f32>;

      struct VertexInput {
          @location(0) position: vec3<f32>,
          @location(1) color: vec3<f32>,
      };
      struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec3<f32>,
      };

      @vertex
      fn main(input:VertexInput)->VertexOutput{
        var output:VertexOutput;
        let worldPos=modelMatrix*vec4<f32>(input.position,1.0);
        output.position=sceneUniform*worldPos;
        output.color=input.color;
        return output;
      }`;

        const localAxesFragmentCode = `
      struct VertexOutput {
          @builtin(position) position: vec4<f32>,
          @location(0) color: vec3<f32>,
      };

      @fragment
      fn fs_main(input:VertexOutput)->@location(0) vec4<f32>{
        return vec4<f32>(input.color,1.0);
      }`;

        const localAxesVertexModule = device.createShaderModule({
          code: localAxesVertexCode,
        });
        const localAxesFragmentModule = device.createShaderModule({
          code: localAxesFragmentCode,
        });

        const localAxesPipeline = device.createRenderPipeline({
          layout: "auto",
          vertex: {
            module: localAxesVertexModule,
            entryPoint: "main",
            buffers: [
              {
                arrayStride: 24,
                attributes: [
                  { shaderLocation: 0, offset: 0, format: "float32x3" },
                  { shaderLocation: 1, offset: 12, format: "float32x3" },
                ],
              },
            ],
          },
          fragment: {
            module: localAxesFragmentModule,
            entryPoint: "fs_main",
            targets: [{ format: preferredFormat }],
          },
          primitive: { topology: "line-list" },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less",
          },
        });

        const { buffer: localAxesBuffer, vertexCount: localAxesVertexCount } =
          (function createLocalAxesBuffer(device) {
            const axesLines = [];
            axesLines.push(...[0, 0, 0, 1, 0, 0]);
            axesLines.push(...[0.5, 0, 0, 1, 0, 0]);
            axesLines.push(...[0, 0, 0, 0, 1, 0]);
            axesLines.push(...[0, 0.5, 0, 0, 1, 0]);
            axesLines.push(...[0, 0, 0, 0, 0, 1]);
            axesLines.push(...[0, 0, 0.5, 0, 0, 1]);

            const data = new Float32Array(axesLines);
            const buf = device.createBuffer({
              size: data.byteLength,
              usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            });
            device.queue.writeBuffer(buf, 0, data);
            return { buffer: buf, vertexCount: axesLines.length / 6 };
          })(device);

        const localAxesBindGroup = device.createBindGroup({
          layout: localAxesPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: sceneBuffer } },
            { binding: 1, resource: { buffer: modelBuffer } },
          ],
        });

        const tankState = {
          position: [0, 0, 0],
          rotation: 0,
          turretRotation: 0,
          barrelElevation: 0,
        };

        const localPivot = [0.65, 0.87, 0];

        function computeBarrelPivot(tankState) {
          let cosR = Math.cos(tankState.rotation);
          let sinR = Math.sin(tankState.rotation);
          let length = Math.sqrt(
            localPivot[0] * localPivot[0] + localPivot[1] * localPivot[1]
          );

          let worldX = tankState.position[0] + length * cosR;
          let worldZ = tankState.position[2] - length * sinR;

          let worldY = tankState.position[1] ?? 0.0;
          worldY += localPivot[1];

          return [worldX, worldY, worldZ];
        }

        function updateShell() {
          if (shellLaunched && !shellPaused) {
            let dt = 1 / 60;
            shellVel[1] -= gravity * dt;
            shellPos[0] += shellVel[0] * dt;
            shellPos[1] += shellVel[1] * dt;
            shellPos[2] += shellVel[2] * dt;
            if (shellPos[1] < 0) {
              shellPos[1] = 0;
              shellVel = [0, 0, 0];
            }
          }
        }

        window.addEventListener("keydown", (e) => {
          let forwardX = Math.cos(tankState.rotation);
          let forwardZ = Math.sin(tankState.rotation);

          const key = e.key.toLowerCase();
          switch (key) {
            case "arrowup":
              tankState.position[0] += forwardX * 0.1;
              tankState.position[2] -= forwardZ * 0.1;
              break;
            case "arrowdown":
              tankState.position[0] -= forwardX * 0.1;
              tankState.position[2] += forwardZ * 0.1;
              break;
            case "arrowleft":
              tankState.rotation += 0.05;
              break;
            case "arrowright":
              tankState.rotation -= 0.05;
              break;
            case "a":
              tankState.turretRotation += 0.05;
              break;
            case "d":
              tankState.turretRotation -= 0.05;
              break;
            // case "w":
            //   tankState.barrelElevation += 0.05;
            //   if (tankState.barrelElevation > 0.5)
            //     tankState.barrelElevation = 0.5;
            //   break;
            // case "s":
            //   tankState.barrelElevation -= 0.05;
            //   if (tankState.barrelElevation < -0.3)
            //     tankState.barrelElevation = -0.3;
            //   break;
            case " ":
              if (!shellLaunched && M_barrel_glob) {
                shellLaunched = true;
                shellPaused = false;

                // // 1) 배럴 끝 (로컬 -> 월드)
                // let localMuzzlePos = [5, 5, 0, 1]; // 약간 위로 올리고 싶으면 y=+0.1
                // let muzzleW = vec4.transformMat4(localMuzzlePos, M_barrel_glob);
                // shellPos = [muzzleW[0], muzzleW[1], muzzleW[2]];
                // console.log(shellPos);

                // // 2) 배럴 방향 (로컬 -> 월드)
                // let localFwd = [1, 0, 0, 0];
                // let fwdW = vec4.transformMat4(localFwd, M_barrel_glob);
                // let dx = fwdW[0],
                //   dy = fwdW[1],
                //   dz = fwdW[2];
                // let len = Math.sqrt(dx * dx + dy * dy + dz * dz);
                // if (len > 1e-6) {
                //   dx /= len;
                //   dy /= len;
                //   dz /= len;
                // }
                // // 3) 초기 속도
                // let speed = 3.0; // 원하시는 값
                // shellVel = [dx * speed, dy * speed + 0.5, dz * speed];
              }
              break;
          }
        });

        function drawPart(renderPass, M, bindGroup, mesh) {
          let invM = mat4.invert(M);
          let normalMat = mat4.transpose(invM);
          device.queue.writeBuffer(modelBuffer, 0, M);
          device.queue.writeBuffer(normalMatrixBuffer, 0, normalMat);

          renderPass.setPipeline(pipeline);
          renderPass.setBindGroup(0, bindGroup);
          renderPass.setVertexBuffer(0, mesh.posBuffer);
          renderPass.setVertexBuffer(1, mesh.normalBuffer);
          renderPass.setVertexBuffer(2, mesh.uvBuffer);
          renderPass.setVertexBuffer(3, mesh.tangentBuffer);
          renderPass.setVertexBuffer(4, mesh.bitangentBuffer);
          renderPass.setIndexBuffer(mesh.indexBuffer, "uint32");
          renderPass.drawIndexed(mesh.indexCount, 1, 0, 0, 0);
        }

        function renderFrame(time) {
          updateShell();

          let M_body = mat4.identity();
          M_body = mat4.translate(M_body, [
            tankState.position[0],
            0.46,
            tankState.position[2],
          ]);
          M_body = mat4.rotate(M_body, [0, 1, 0], tankState.rotation);

          let M_turret = mat4.clone(M_body);
          M_turret = mat4.rotate(M_turret, [0, 1, 0], tankState.turretRotation);

          let M_barrel = M_turret;
          // M_barrel = mat4.rotateX(M_barrel, tankState.barrelElevation);
          // M_barrel = mat4.translate(M_barrel, [
          //   -barrelPivot[0],
          //   -barrelPivot[1],
          //   -barrelPivot[2],
          // ]);

          const barrelPivot = computeBarrelPivot(tankState);
          for (let i = 0; i < 16; i++) M_barrel_glob[i] = barrelPivot[i];

          let M_innerWheel = M_body;
          let M_outerWheel = M_body;

          let M_shell_t = mat4.identity();
          M_shell_t = mat4.translate(M_shell_t, M_barrel_glob);
          M_shell_t = mat4.rotate(M_shell_t, [0, 1, 0], tankState.rotation);
          M_shell_t = mat4.scale(M_shell_t, [1.1, 1.1, 1.1]);

          // 라이트 설정
          const lightDir = new Float32Array([-1, 5, 5]);
          device.queue.writeBuffer(lightBuffer, 0, lightDir);

          device.queue.writeBuffer(sceneBuffer, 0, UI.matrices.VP);

          const depthTexture = createDepthTexture(
            device,
            canvas.width,
            canvas.height,
            "depth24plus"
          );
          const commandEncoder = device.createCommandEncoder();
          const textureView = context.getCurrentTexture().createView();

          const renderPass = commandEncoder.beginRenderPass({
            colorAttachments: [
              {
                view: textureView,
                loadOp: "clear",
                clearValue: { r: 0.3, g: 0.3, b: 0.3, a: 1 },
                storeOp: "store",
              },
            ],
            depthStencilAttachment: {
              view: depthTexture.createView(),
              depthLoadOp: "clear",
              depthClearValue: 1.0,
              depthStoreOp: "store",
            },
          });

          // 그리드
          renderPass.setPipeline(gridPipeline);
          renderPass.setBindGroup(0, gridBindGroup);
          renderPass.setVertexBuffer(0, gridBuffer);
          renderPass.draw(gridVertexCount, 1, 0, 0);

          // 탱크 파츠 드로우
          drawPart(renderPass, M_body, bindGroup_Body, meshData[0]);
          drawPart(renderPass, M_turret, bindGroup_Turret, meshData[1]);
          drawPart(renderPass, M_innerWheel, bindGroup_InnerWheel, meshData[2]);
          drawPart(renderPass, M_outerWheel, bindGroup_OuterWheel, meshData[3]);
          drawPart(renderPass, M_barrel, bindGroup_Barrel, meshData[4]);

          if (shellLaunched) {
            device.queue.writeBuffer(modelBufferShell, 0, M_shell_t);
            device.queue.writeBuffer(
              normalMatrixBufferShell,
              0,
              someInvTransposeOf(M_shell_t)
            );

            renderPass.setPipeline(pipelineShell);
            renderPass.setBindGroup(0, bindGroup_Shell);
            renderPass.setVertexBuffer(0, shellData[0].posBuffer);
            renderPass.setVertexBuffer(1, shellData[0].normalBuffer);
            renderPass.setVertexBuffer(2, shellData[0].uvBuffer);
            renderPass.setVertexBuffer(3, shellData[0].tangentBuffer);
            renderPass.setVertexBuffer(4, shellData[0].bitangentBuffer);
            renderPass.setIndexBuffer(shellData[0].indexBuffer, "uint32");
            renderPass.drawIndexed(shellData[0].indexCount, 1, 0, 0, 0);
          }

          // 로컬 축
          device.queue.writeBuffer(modelBuffer, 0, M_body);
          renderPass.setPipeline(localAxesPipeline);
          renderPass.setBindGroup(0, localAxesBindGroup);
          renderPass.setVertexBuffer(0, localAxesBuffer);
          renderPass.draw(localAxesVertexCount, 1, 0, 0);

          renderPass.end();
          device.queue.submit([commandEncoder.finish()]);
          requestAnimationFrame(renderFrame);
        }

        requestAnimationFrame(renderFrame);

        window.addEventListener("resize", () => {
          canvas.width = canvas.clientWidth * devicePixelRatio;
          canvas.height = canvas.clientHeight * devicePixelRatio;
          context.configure({ device, format: preferredFormat });
        });
      }

      main();
    </script>
  </body>
</html>
